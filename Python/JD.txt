As a Principal Engineer, you will be at the forefront of designing and implementing cutting-edge solutions and monitoring infra tools and systems deployment that shape the future of our products.

Working on the development of technical strategies and roadmaps to guide long-term engineering initiatives
Collaborate with cross-functional teams to work on requirements and by understanding them deeper into technical specifications
Provide mentorship to engineering teams, fostering a culture of innovation and continuous improvement
Recommend new technologies, tools, and methodologies to enhance our engineering capabilities
Drive the resolution of complex technical challenges and make critical design decisions
Participate in the full development lifecycle, from concept to deployment till the maintenance
Contribute to the establishment of engineering standards, best practices, and documentation
Represent the team in design and development related discussions with stakeholders and external partners
Qualifications

Bachelor's or Master's degree in Computer Science, Engineering, or a related field, or equivalent practical experience

3+ years of software engineering experience
Thorough understanding of software architecture, design patterns, and system design principles
Proven track record of working on large to mid-scale, complex software projects from conception to successful delivery
Strong programming skills in language: Python Advanced, C++(Optional)
Basic understanding of CI/CD practices and tools, version control systems (e.g., Git), and agile methodologies
Understanding of performance optimization, scalability, and reliability in large to mid-scale systems
Excellent problem-solving skills with the ability to analyze complex issues and develop innovative solutions
Outstanding communication and interpersonal skills, with the ability to collaborate effectively across teams and influence technical decisions
Good knowledge of Flash Memory concepts, Protocol knowledge such as UFS or eMMC shall be an added advantage
Work to mentor and develop junior engineers in the team
Familiarity with monitoring, logging, and observability tools and practices
Strong analytical mindset with attention to detail and a data-driven approach to decision-making
Ability to balance technical excellence with pragmatic solutions to meet business objectives


1. NAND Flash & Firmware Concepts
Goal: Understand how firmware manages NAND flash devices.

ğŸ“˜ Core Topics:
NAND flash fundamentals (SLC/MLC/TLC/QLC)
FTL (Flash Translation Layer)
Wear leveling, garbage collection, TRIM
Bad block management and ECC (Error Correction Code)
Power loss management in NAND
Bootloader and boot processes in embedded systems

ğŸ›  Tools to learn:
Logic analyzers, protocol analyzers (e.g., Lecroy, TotalPhase)
JTAG/UART debugging

âœ… 2. Storage Protocols
Goal: Master host interface protocols and their command flows.

ğŸ“˜ Primary Protocols (Must know):
UFS, eMMC â€“ mobile & embedded storage
SCSI (used in UFS command layer)
Command layer: SCSI over UPIU (UFS Protocol Information Unit)
ğŸ“˜ Added Advantage (Know basics): NVMe, PCIe, SATA

ğŸ” Key Concepts:
Command sequences (read, write, flush, trim, etc.)
LUNs (Logical Unit Numbers), Queues, Descriptors
Data paths from host to NAND and back

3. Validation & Testing Knowledge
Goal: Build and run test suites and analyze failures.

ğŸ“˜ Testing Concepts:

Regression testing, functional & compatibility testing
Test coverage in real-time embedded systems
Black box & white box testing for storage
Automated testing for firmware & hardware

ğŸ§ª What to Learn:

Writing custom test scripts (Python/C++)
Analyzing test logs and validation reports
Using protocol traces to debug failures
Fault injection & corner case testing

âœ… 4. Programming & Debugging
Goal: Write tools and debug firmware/hardware interactions.

ğŸ“˜ Languages:

Python: Scripting test cases, automation, trace analysis
C/C++: Firmware-level testing and debugging
Shell scripting: Linux-based test environments

ğŸ›  Skills:

Memory dump analysis
Stack trace reading
Instrumenting code for debugging (print logs, assert handling)

âœ… 5. Operating Systems & File Systems
Goal: Understand how the OS interacts with storage.

ğŸ“˜ Operating Systems:

Linux (kernel logs: dmesg, device probing: lsblk, iostat, smartctl)
Android (especially for UFS/eMMC)
Basic mobile/computer OS storage stack

ğŸ“ File Systems:
FAT32, exFAT, ext4
How file systems affect read/write patterns and wear

âœ… 6. Tools & Debugging Infrastructure
Goal: Use tools to inspect hardware/software interactions.

ğŸ›  Tools:
Protocol analyzers: Understand trace formats
JTAG/debug ports for embedded boards
Trace viewers: Lecroy USB Suite, TotalPhase Data Center, UFS Command Viewer (if available)



âœ… 8. Bonus (if you want to stand out)
ğŸ“˜ Digital and Analog Design Basics:

Digital logic, state machines, timing diagrams
Basics of signal integrity and layout (for board-level validation)

